# Low-Pass Filters for Signal Processing
For most of the cases of our simulations, such as the dynamics initiated by non-ground states, there are multiple frequencies in the time-dependent properties and often the high-frequency oscilations give us unwanted noise. Here are two types of low-pass filters that you can use to handle this problem. 

## $\sin^4$ rolling low-pass filter
This window function has the parametric form: 
$$w_{t_c}(t) = \sin^4(\frac{\pi\times(t-t_0)}{t_{end}-t_0}),$$
and then normalize it with:
$$w_{t_c}(t) = \frac{w_{t_c}(t)}{\int^{t_{end}}_{t_0}w_{t_c}(t)dt}$$
where $t_{end}$ and $t_0$ is within $t_c\pm 0.5\times width$. It selects a period of $\sin^4(\pi\times x)$, brodens it with the window width ($t_{end}-t_0$), and then shift it with $t_0$. The following plot is the normalized`1fs`-window function centered at `4.83fs`.

<figure>
    <img align="center" src=https://i.imgur.com/w41ckTs.png><figcaption align = "center"><center><I>Window function centered at around t<sub>c</sub>=4.83fs. </I></center></figcaption>
</figure>

> Note that at the boundary of the signals, since $t_c \pm 0.5\times width$ will be out of the time range, there will be that $t_{end}-t_0 < width$. 
> 
<figure>
    <img align="center" src=https://i.imgur.com/HFwgnfm.png><figcaption align = "center"><center><I>Window function centered at t<sub>c</sub>=0 fs and around t<sub>c</sub>=4.83 fs. </I></center></figcaption>
</figure>

By rolling over the time steps, this filter smooths the signal by masking the window $w_{t_c}(t)$ to the corresponding time signal:
$$f'(t) = \int^{t_{max}}_0\int^{t_{end}}_{t_0}w_{t_c}(t)f_{tc}(t)dt, $$
where $f'(t)$ is the filtered signal, it's basically a convolution step without "conv" and this procudure is 
like adding a Gaussian blur to the signal. Below is a gif shows how to get the filtered signal for $t_c=190$ au. 
<figure>
    <img align="center" src=https://i.imgur.com/stvTinm.gif><figcaption align = "center"><center><I>Yellow dot denotes the chosen center t<sub>c</sub>. The filtered data is the integral of f(x)*w(x), which is the area under the purple curve.  </I></center></figcaption>
</figure>


#### How it is implemented
For a data set consist of `t[nt]`, `y[nt]`, do these steps for each time step:
1. set this timestep as the center of the window, $t_c$.
2. find time steps $t_{chosen}$ that reside within $t_{c} \pm0.5 \times width$. The corresponding data values are $y_{chosen}$.
3. calculate this window function with $t_{chosen}$. $$w_{t_c}(t) = \sin^4(\frac{\pi\times(t-t_{chosen}[0])}{t_{chosen}[-1]-t_{chosen}[0]})$$
4. normalize the window by the sum of the window elements.
5. do dot production $w_{t_c}(t) \cdot y_{chosen}$ and then sum these elements(convolution step). The sum will be the filtered value for this time step.


The plots below are the dipole moment filtered with the `1fs`-$\sin^4$ window. The first plot is generated by filtering `12fs`signal, while the second is the comparision between filtering over `4fs` and `12fs` signal. It can be seen that the "head" and "tail" of the filtered signal are not reliable. It's always a good idea to have a larger signal set to get good results. 
> Note that there is no strict relationship between the signal length and window width. As long as the cutoff energy is above your main frequency (what you want to keep), the filtering in principle will work, and thus you need to play around to get the optimized signal length. 

The cutoff frequency of this filter is actually not determined. One reason is that the width of the window changes over $t_c$. Also, for a rectangular filter, the cutoff angular frequency is $\frac{2\pi}{width}$, therefore, for the $\sin^4$ shape filter, the cutoff angular frequency is $\frac{2\pi}{width}\times c$, where $1<c<2$. But still, we can use $\frac{2\pi}{width}$ to approximate the cutoff energy (remember to convert the unit of width into `au` if it's `fs`).
![](https://i.imgur.com/smeGQYf.png)




## Butterworth filter
[Butterworth](https://en.wikipedia.org/wiki/Butterworth_filter) is a more versatile filter that cannot only enable low-pass but also high-pass and band-pass by specifying the cutoff energies. 
<figure>
<img align="center" src="
https://i.imgur.com/WyyeJ9F.png">
<figcaption align = "center"><I>The blue solid line, orange dashed line, and green solid line shows the frequency response of a 10 evlow-pass filter, a 10~20 ev band-pass and a 20 ev high-pass filter, respectively. </I></figcaption>
</figure>

#### How it is implemented
Butterworth filter has well-developed libaray in both python Scipy library and Matlab. It basically has two steps, taking the Scipy.signal as example:
1. calculate the transfer function coefficients `a` and `b`:

    `b, a = scipy.signal.butter(order, cutoff, btype='low', analog=False, output='ba', fs=fs)`
    
    `order`: the order of the butterworth filter. The higher the order, the steeper the transition band slope. Typically set as 5 or 6.
    `cutoff`: the cutoff energy
    `btype`: the type of the butterworth filter ('low' or 'high' or 'band')
    `analog`: if it's an analog filter. It's digital filter in our case so set to false.
    `output`: set to 'ba' so that returns the `a`,`b` coefficients
    `fs`: sampling frequency. Note the unit has to be the same as cutoff energy (both Hz or both rad/s)
    
   You can check the frequency response by using `freqz`:
   
    `l, h = scipy.signal.freqz(b, a, fs=fs, worN=2000)` 
    
2. do the convolution with `filtfilt` method

    ` y = scipy.signal.filtfilt(b, a, unfiltered_y)`

Same as the $\sin^4$ window, the "head" and "tail" of the filtered signal is not reliable. Therefore it's always to use a larger signal set than the desired one. The following plot shows the filtered `12fs `and `4fs` signal using a `4eV` butterworth filter. 
![](https://i.imgur.com/pYufQGH.png)

The plot below shows the filtered `12fs `signal using `4ev` butterworth and `1fs` $\sin^4$ filter. These two filters give almost the same filtered signal except at the beginneg and end of the signal. 
![](https://i.imgur.com/QYQ4Tc6.png)

## Conclusion
Both $\sin^4$ and Butterworth filter can be applied to remove the high-frequency signal around cutoff energy using convolution. However, I'd prefer the Butterworth filter since it has determinate cutoff energy and is more intuitive to use. When applying these filters to volumetric data, testig on the 2d dipole signal to find the optimized time range is always a good idea. 

## References
1. useful information about how Butterworth is implemented:
https://www.mathworks.com/help/signal/ref/butter.html
2. explanation of what filtfilt actually does:
https://stackoverflow.com/questions/60707699/what-actually-are-the-transfer-functions-in-filtfilt-matlabs-zero-offset-filte
3. explanation of filtfilt and transfer function coefficients:
https://www.mathworks.com/help/signal/ref/filtfilt.html
4. example codes and units explanation of the Butterworth filter:
https://stackoverflow.com/questions/25191620/creating-lowpass-filter-in-scipy-understanding-methods-and-units
5. other low-pass filter: moving average
https://dsp.stackexchange.com/questions/49174/a-basic-question-about-the-use-of-moving-average-vs-low-pass-filters-in-dsp
6. $\sin$ and power of $\sin$ window
https://en.wikipedia.org/wiki/List_of_window_functions#Power-of-sine/cosine_windows